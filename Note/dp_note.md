# Dynamic Programming

所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

## 解题步骤

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

对于动态规划问题五步骤：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## DP三省

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？


## 题目

**代码随想录刷题**
- 0746.medium.使用最小花费爬楼梯
- 0516.medium.最长回文子序列
- 0062.medium.不同路径
- 0063.medium.不同路径II，在上一题的任务上增加了障碍物约束
    - dp[i][j] = 0 if i,j 障碍物 else dp[i][j] = 左边数量 和 上方路径数量
- 0343.!.medium.整数拆分 
    - max(分成两个数字的结果，分成超过两个数字的结果)
    - `dp[n] = max([j * (i-j) for j in range(1, i)] + [j * dp[i-j] for j in range(1, i)])`
    - 优化，仅考虑 2和 3 的拆分
- 0096.medium.不同的二叉搜索树
    - 以此以n个节点的每个节点为根，该情况下左边数量*右边数量即该节点为根的组合数量
    - `dp[n] = sum([dp[j-1] * dp[i-j] for j in range(i+1)])`
- pure 01背包 见Note中的文件
    - dp[i][j]  i:[0~i] 的物品; j: 
    - max(不放当前物品的价值，放当前物品的价值 + 剩下空间放旧物品的最大价值)
- 0337.medium.打家劫舍 III
    - 二叉树遍历，构造最优子结构
- 0416.medium.分割等和子集 01背包，目标为判断能否装满 sum/2
- 1049.medium.最后一块石头的重量 II
    - 背包构造，石头辗转碎裂。 -> 将石头分成尽可能重量接近的两个部分
- 


**难题**
- 0010.hard.!.正则表达式匹配.py

**力扣算法计划刷题**
- 0055.medium.跳跃游戏
- 0045.medium.跳跃游戏 II; 贪心算法，和dp思路接近但是不许咬存储空间；动态规划，dp存放每个位置的元素最少需要多少步
- 0070 easy 爬楼梯
- 0072.hard.!.编辑距离
- 0091.medium.解码方法
- 0120 medium ！三角形最小路径和
- 0139.medium.单词拆分
- 0198.medium.!.打家劫舍
- 0213.medium.打家劫舍II
- 0300.medium.!.最长递增子序列
- 0413.medium.!.等差数列个数  滑窗 -> 动规

**TODO**
673. 最长递增子序列的个数
1143. 最长公共子序列
583. 两个字符串的删除操作
322. 零钱兑换
149. 直线上最多的点数
0494  DP 方案
